<!DOCTYPE html>
<html>
<head>
  <title>chordsMX VR Keyboard</title>
  <meta name="description" content="A VR prototype for the ChordGlove gesture typing system with Gemini API features.">
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.3.4/dist/aframe-environment-component.min.js"></script>
  <script src="https://unpkg.com/aframe-rounded-component@0.1.1/dist/aframe-rounded-component.min.js"></script>
</head>
<body>
  <!--
    HOW TO NAVIGATE THE MENU:
    - Point at buttons with your RIGHT hand. A laser will appear.
    - Make a quick "pinch" gesture with your thumb and index finger on your RIGHT hand to select.
  -->
  <a-scene environment="preset: starry; ground: none;" renderer="colorManagement: true;">
    <!-- Assets -->
    <a-assets>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    </a-assets>

    <!-- Camera -->
    <a-entity id="camera" camera position="0 1.6 0" look-controls="enabled: false" wasd-controls="enabled: false"></a-entity>

    <!-- Hand Tracking Entities -->
    <a-entity id="leftHand" hand-tracking-controls="hand: left;"></a-entity>
    <a-entity id="rightHand"
              hand-tracking-controls="hand: right;"
              laser-controls="hand: right"
              raycaster="objects: .clickable; far: 5;">
    </a-entity>


    <!-- Main UI Layout -->
    <a-entity id="main-ui" position="0 1.6 -1.8" visible="false">
        <a-entity rounded="width: 1.8; height: 1; radius: 0.05" material="color: #101015; shader: flat; opacity: 0.7">
            <a-entity text="value: chordsMX; color: #fff; anchor: left; width: 1.6; font: roboto;" position="-0.8 0.4 0.01"></a-entity>
            <a-entity id="textDisplay" position="-0.8 0.3 0.01" text="value: Start typing...; color: #FFF; align: left; anchor: left; baseline: top; wrapCount: 35; width: 1.55; font: roboto;"></a-entity>
            <!-- Version Number Placeholder -->
            <a-entity text="value: v20; color: #fff; anchor: right; align: right; width: 1.6; font: roboto; opacity: 0.5;" position="0.8 -0.45 0.01"></a-entity>
        </a-entity>
        <a-entity class="clickable" data-raycastable id="summarize-button" position="-1.15 0.25 0" rounded="width: 0.4; height: 0.15; radius: 0.03" material="color: #283350; shader: flat; opacity: 0.8">
            <a-entity text="value: ✨ Summarize; color: #fff; align: center; width: 0.8; font: roboto;" position="0 0 0.01"></a-entity>
        </a-entity>
        <a-entity class="clickable" data-raycastable id="complete-button" position="1.15 0.25 0" rounded="width: 0.4; height: 0.15; radius: 0.03" material="color: #283350; shader: flat; opacity: 0.8">
            <a-entity text="value: ✨ Complete; color: #fff; align: center; width: 0.8; font: roboto;" position="0 0 0.01"></a-entity>
        </a-entity>
        <a-entity id="loading-indicator" visible="false" position="0 0 0.02" geometry="primitive: ring; radiusInner: 0.1; radiusOuter: 0.12" material="color: #ffffff; shader: flat" animation="property: rotation; to: 0 0 -360; loop: true; dur: 1000; easing: linear;"></a-entity>
    </a-entity>

    <!-- Onboarding Tutorial UI -->
    <a-entity id="tutorial" visible="true" position="0 1.6 -1.5">
        <a-entity rounded="width: 1.4; height: 0.8; radius: 0.05" material="color: #181820; shader: flat; opacity: 0.8">
             <a-entity material="shader: flat; color: #fff; opacity: 0.1" rounded="width: 1.4; height: 0.8; radius: 0.05" position="0 0 0.001"></a-entity>
        </a-entity>
        <a-entity id="tutorial-content" position="0 0 0.01">
            <a-entity id="tutorial-title" text="value: Training Menu; color: #fff; align: center; width: 2; font: roboto;" position="0 0.3 0"></a-entity>
            <a-entity id="tutorial-prompt" text="value: Select a lesson to begin.; color: #ccc; align: center; width: 1.2; wrapCount: 50; font: roboto;" position="0 0.2 0"></a-entity>
            <a-entity id="feedback-correct" text="value: ✔; color: #4CAF50; align: center; width: 2" position="0 0 0.01" visible="false" scale="1.5 1.5 1.5"></a-entity>
            <a-entity id="feedback-incorrect" text="value: ✖; color: #F44336; align: center; width: 2" position="0 0 0.01" visible="false" scale="1.5 1.5 1.5"></a-entity>
            <a-entity id="lesson-menu" visible="true">
                <a-entity class="clickable lesson-button" data-raycastable id="lesson-btn-1" position="-0.35 -0.05 0" rounded="width: 0.6; height: 0.15; radius:0.02" material="color: #4285F4">
                    <a-entity text="value: 1. Basic Letters; color: #fff; align: center; width: 1.2; font: roboto;" position="0 0 0.01"></a-entity>
                </a-entity>
                <a-entity class="clickable lesson-button" data-raycastable id="lesson-btn-2" position="0.35 -0.05 0" rounded="width: 0.6; height: 0.15; radius:0.02" material="color: #4285F4">
                     <a-entity text="value: 2. Common Words; color: #fff; align: center; width: 1.2; font: roboto;" position="0 0 0.01"></a-entity>
                </a-entity>
                <a-entity class="clickable lesson-button" data-raycastable id="lesson-btn-3" position="0 -0.25 0" rounded="width: 0.6; height: 0.15; radius:0.02" material="color: #4285F4">
                     <a-entity text="value: 3. Punctuation; color: #fff; align: center; width: 1.2; font: roboto;" position="0 0 0.01"></a-entity>
                </a-entity>
            </a-entity>
            <a-entity class="clickable" data-raycastable id="exit-button" position="0 -0.32 0" rounded="width: 0.4; height: 0.1; radius:0.02" material="color: #252525">
                <a-entity text="value: Exit Training; color: #fff; align: center; width: 1; font: roboto;" position="0 0 0.01"></a-entity>
            </a-entity>
        </a-entity>
    </a-entity>

    <a-entity id="chordglove-system" chordglove-logic></a-entity>

  </a-scene>

  <script>
    AFRAME.registerComponent('chordglove-logic', {
      schema: {
        pinchThreshold: { type: 'number', default: 0.02 },
        fistThreshold: { type: 'number', default: 0.03 },
        thumbUpThreshold: { type: 'number', default: 0.05 },
        typingCooldown: { type: 'number', default: 250 },
        actionCooldown: { type: 'number', default: 2000 }
      },

      init: function () {
        this.leftHand = document.querySelector('#leftHand');
        this.rightHand = document.querySelector('#rightHand');
        this.textDisplay = document.querySelector('#textDisplay');
        this.loadingIndicator = document.querySelector('#loading-indicator');
        this.tutorialEntity = document.querySelector('#tutorial');
        this.mainUI = document.querySelector('#main-ui');
        this.tutorialTitle = document.querySelector('#tutorial-title');
        this.tutorialPrompt = document.querySelector('#tutorial-prompt');
        this.lessonMenu = document.querySelector('#lesson-menu');
        this.feedbackCorrect = document.querySelector('#feedback-correct');
        this.feedbackIncorrect = document.querySelector('#feedback-incorrect');
        
        this.typedText = '';
        this.isApiLoading = false;
        this.tutorialState = 'menu';
        this.currentLesson = null;
        this.lessonStep = 0;
        this.lessonCorrect = 0;
        this.lessonIncorrect = 0;

        this.cooldowns = { left: false, right: false, leftAction: false, rightAction: false };
        this.chordState = { left: null, right: null };

        this.chords = {
          left: { 'thumb-index': 'e', 'thumb-middle': 'a', 'thumb-ring': 'o', 'thumb-pinky': 'i', 'thumb-index-middle': 'r', 'thumb-middle-ring': 'l', 'thumb-index-middle-ring': '1', 'thumb-index-middle-pinky': '2' },
          right: { 'thumb-index': 't', 'thumb-middle': 'n', 'thumb-ring': 's', 'thumb-pinky': 'h', 'thumb-index-middle': 'd', 'thumb-middle-ring': 'c', 'thumb-index-middle-ring': '!', 'thumb-index-middle-pinky': '?' }
        };
        this.fingerJoints = { thumb: 'thumb-tip', index: 'index-finger-tip', middle: 'middle-finger-tip', ring: 'ring-finger-tip', pinky: 'pinky-finger-tip', wrist: 'wrist' };
        
        this.trainingModules = {
            'Basic Letters': { title: 'Lesson 1: Basic Letters', exercises: ['e', 't', 'a', 'n', 'o', 's', 'i', 'h', 'r', 'd'] },
            'Common Words': { title: 'Lesson 2: Common Words', exercises: ['the', 'and', 'a', 'to', 'in', 'is', 'it', 'you', 'that', 'he'] },
            'Punctuation': { title: 'Lesson 3: Punctuation', exercises: ['!', '?'] }
        };
        
        this.addEventListeners();
        this.updateTextDisplay();
      },
      
      addEventListeners: function() {
        document.querySelector('#exit-button').addEventListener('click', this.endTutorial.bind(this));
        document.querySelectorAll('.lesson-button').forEach(button => {
            button.addEventListener('click', (evt) => {
                const textEntity = evt.currentTarget.querySelector('a-entity');
                if (textEntity) {
                    const buttonText = textEntity.getAttribute('text').value;
                    const lessonName = buttonText.split('. ')[1];
                    this.startLesson(lessonName);
                }
            });
        });
        
        const clickableEls = document.querySelectorAll('.clickable');
        clickableEls.forEach(el => {
            el.addEventListener('mouseenter', () => { 
                el.setAttribute('animation', { property: 'scale', to: '1.1 1.1 1.1', dur: 200 });
            });
            el.addEventListener('mouseleave', () => { 
                el.setAttribute('animation', { property: 'scale', to: '1 1 1', dur: 200 });
            });
        });
      },

      tick: function () {
        if (this.areJointsTracked(this.leftHand)) {
            this.updateHandState(this.leftHand, 'left');
        } else {
            this.chordState.left = null;
        }

        if (this.areJointsTracked(this.rightHand)) {
            this.updateHandState(this.rightHand, 'right');
        } else {
            this.chordState.right = null;
        }
      },

      updateHandState: function(handEl, handSide) {
          if (this.cooldowns[handSide]) return;
          
          const currentChord = this.getChordCharacter(handEl, handSide);
          const isThumbsUp = this.isThumbsUp(handEl);
          const actionCooldownSide = handSide + 'Action';

          if (!this.cooldowns[actionCooldownSide] && isThumbsUp && !currentChord) {
              if (this.tutorialState === 'finished') {
                  if (handSide === 'right') this.completeText();
                  else this.summarizeText();
              }
              this.setCooldown(actionCooldownSide, this.data.actionCooldown);
              return;
          }

          if (currentChord && this.chordState[handSide] !== currentChord) {
              this.chordState[handSide] = currentChord;
              if (this.tutorialState === 'in-lesson') {
                  this.handleLessonInput(currentChord);
              } else if (this.tutorialState === 'finished') {
                  this.typeCharacter(currentChord);
              }
              this.setCooldown(handSide, this.data.typingCooldown);
          } else if (!currentChord) {
              this.chordState[handSide] = null;
          }
      },
      
      startLesson: function(lessonName) {
          this.currentLesson = this.trainingModules[lessonName];
          if (!this.currentLesson) return;
          this.tutorialState = 'in-lesson';
          this.lessonStep = 0;
          this.lessonCorrect = 0;
          this.lessonIncorrect = 0;
          this.lessonMenu.setAttribute('visible', 'false');
          this.updateLessonDisplay();
      },

      updateLessonDisplay: function() {
          if (this.lessonStep >= this.currentLesson.exercises.length) {
              this.endLesson();
              return;
          }
          this.tutorialTitle.setAttribute('text', 'value', this.currentLesson.title);
          const exercise = this.currentLesson.exercises[this.lessonStep];
          this.tutorialPrompt.setAttribute('text', 'value', \`Type: "\${exercise}"\`);
          this.typedText = '';
          this.updateTextDisplay();
      },

      handleLessonInput: function(character) {
          this.typedText += character;
          this.updateTextDisplay();

          const currentExercise = this.currentLesson.exercises[this.lessonStep];
          if (this.typedText.length >= currentExercise.length) {
              if (this.typedText === currentExercise) {
                  this.lessonCorrect++;
                  this.showFeedback(true);
              } else {
                  this.lessonIncorrect++;
                  this.showFeedback(false);
              }
              this.lessonStep++;
              setTimeout(() => this.updateLessonDisplay(), 800);
          }
      },

      showFeedback: function(isCorrect) {
          const feedbackEl = isCorrect ? this.feedbackCorrect : this.feedbackIncorrect;
          feedbackEl.setAttribute('visible', true);
          setTimeout(() => feedbackEl.setAttribute('visible', false), 700);
      },

      endLesson: function() {
          const total = this.lessonCorrect + this.lessonIncorrect;
          const accuracy = total > 0 ? Math.round((this.lessonCorrect / total) * 100) : 100;
          this.tutorialTitle.setAttribute('text', 'value', 'Lesson Complete!');
          this.tutorialPrompt.setAttribute('text', 'value', \`Accuracy: \${accuracy}%\n\nReturning to menu...\`);
          setTimeout(() => this.showTutorialMenu(), 3000);
      },

      showTutorialMenu: function() {
          this.tutorialState = 'menu';
          this.lessonMenu.setAttribute('visible', 'true');
          this.tutorialTitle.setAttribute('text', 'value', 'Training Menu');
          this.tutorialPrompt.setAttribute('text', 'value', 'Select a lesson to begin.');
      },

      endTutorial: function() {
          this.tutorialState = 'finished';
          this.tutorialEntity.setAttribute('visible', 'false');
          this.mainUI.setAttribute('visible', 'true');
          this.typedText = '';
          this.updateTextDisplay();
      },

      getChordCharacter: function(handEl, handSide) {
          const joints = handEl.components['hand-tracking-controls'].joints;
          if (!joints[this.fingerJoints.thumb]) return null;
          
          const thumbTipPos = new THREE.Vector3();
          joints[this.fingerJoints.thumb].getWorldPosition(thumbTipPos);
          let activeFingers = [];
          
          const fingerNames = ['index', 'middle', 'ring', 'pinky'];
          for (const finger of fingerNames) {
              const fingerJoint = joints[this.fingerJoints[finger]];
              if (!fingerJoint) continue; 
              const fingerTipPos = new THREE.Vector3();
              fingerJoint.getWorldPosition(fingerTipPos);
              if (thumbTipPos.distanceTo(fingerTipPos) < this.data.pinchThreshold) {
                  activeFingers.push(finger);
              }
          }

          if (activeFingers.length === 0) return null;
          const chordId = 'thumb-' + activeFingers.sort().join('-');
          return this.chords[handSide][chordId] || null;
      },
      
      isThumbsUp: function(handEl) {
          const joints = handEl.components['hand-tracking-controls'].joints;
          const requiredJointNames = ['wrist', 'thumb', 'index', 'middle', 'ring', 'pinky'];
          for (const joint of requiredJointNames) {
              if (!joints[this.fingerJoints[joint]]) return false;
          }
          const wristPos = new THREE.Vector3();
          const thumbTipPos = new THREE.Vector3();
          joints[this.fingerJoints.wrist].getWorldPosition(wristPos);
          joints[this.fingerJoints.thumb].getWorldPosition(thumbTipPos);
          let isFist = true;
          for (const finger of ['index', 'middle', 'ring', 'pinky']) {
              const fingerTipPos = new THREE.Vector3();
              joints[this.fingerJoints[finger]].getWorldPosition(fingerTipPos);
              if (fingerTipPos.distanceTo(wristPos) > this.data.fistThreshold) {
                  isFist = false;
                  break;
              }
          }
          return isFist && (thumbTipPos.distanceTo(wristPos) > this.data.thumbUpThreshold);
      },
      
      async callGemini(prompt) {
          if (this.isApiLoading) return null;
          this.isApiLoading = true;
          this.loadingIndicator.setAttribute('visible', true);
          let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
          const payload = { contents: chatHistory };
          const apiKey = "";
          const apiUrl = \`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=\${apiKey}\`;
          try {
              const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
              const result = await response.json();
              if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                  return result.candidates[0].content.parts[0].text;
              }
              return "Error: Could not process response.";
          } catch (error) {
              return "Error: API call failed.";
          } finally {
              this.isApiLoading = false;
              this.loadingIndicator.setAttribute('visible', false);
          }
      },
      
      async completeText() {
          if (!this.typedText || this.tutorialState !== 'finished') return;
          const prompt = \`Continue the following text naturally:\n\n"\${this.typedText}"\`;
          const completion = await this.callGemini(prompt);
          if (completion) this.typeCharacter(' ' + completion.trim());
      },

      async summarizeText() {
          if (!this.typedText || this.tutorialState !== 'finished') return;
          const prompt = \`Summarize the following text into a single, concise sentence:\n\n"\${this.typedText}"\`;
          const summary = await this.callGemini(prompt);
          if (summary) {
              this.typedText = summary.trim();
              this.updateTextDisplay();
          }
      },

      setCooldown: function(side, duration) {
        this.cooldowns[side] = true;
        setTimeout(() => { this.cooldowns[side] = false; }, duration);
      },
      
      areJointsTracked: function(handEl) {
          return handEl.components['hand-tracking-controls']?.joints?.['wrist'];
      },

      typeCharacter: function (char) {
        this.typedText += char;
        this.updateTextDisplay();
      },

      updateTextDisplay: function() {
        this.textDisplay.setAttribute('text', 'value', this.typedText || ' ');
      }
    });
  </script>
</body>
</html>
